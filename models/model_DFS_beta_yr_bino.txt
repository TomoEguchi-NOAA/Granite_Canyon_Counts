# JAGS model for imputing missing gray whale counts at Granite Canyon, CA

# The known cyclical nature of gray whale migration is modeled by the discrete 
# Fourier series of one period per year. Gray whale migration starts
# December 1 and ends February 28 each season. Observed counts are 
# limited so they are used to determine amplitude of each season.  

model{

  for (yr in 1:n.years){
		# Initial states     
		N0[yr] ~ dnorm(mu.N0[yr], 1.0)  #tau.X0[j])
		N[yr, 1] <- c[yr, day[1]] + N0[yr]  # day 1 should be 12/1
		# observation
		y[yr,1] ~ dbin(obs.prob[yr,1], N[yr,1])  #dnorm(N[yr,1], tau.y)

		logit(prob[yr,1]) <- logit(mean.prob) + (BF.Switch*BF.Fixed*bf[yr,1]) + (VS.Switch*VS.Fixed*vs[yr,1]) + (OBS.Switch*OBS.RF[obs[yr,1]])

        # the u data is whether there were observers on watch. 
        # 0 counts are often associated with years/shifts with 
        # no second observer. So if u=0, it will fix observation probability at 0
        obs.prob[yr,1] <- u[yr,t]*prob[yr,1]

		for (t in 2:n.steps){
			# state
			N[yr,t] <-  c[yr, day[t]] + N[yr, t-1]

			# observation
			y[yr, t] ~ dbin(obs.prob[yr,1], N[yr,1])  #dnorm(N[yr,1], tau.y)

			logit(prob[yr,t]) <- logit(mean.prob) + (BF.Switch*BF.Fixed*bf[yr,t]) + (VS.Switch*VS.Fixed*vs[yr,t]) + (OBS.Switch*OBS.RF[obs[yr,t]])

			# the u data is whether there were observers on watch. 
			# 0 counts are often associated with years/shifts with 
			# no second observer. So if u=0, it will fix observation probability at 0
			obs.prob[yr,t] <- u[yr,t]*prob[yr,t]
              
		}
  }  
  
  # c parameter defined here with a discrete Fourier function
  # n.days = from 12/21 to 4/30. Provide it through jags.data
  # also provide period (should be same as n.days) through jags.data

  for (yr in 1:n.years){
    for (j in 1:n.sectors){
      for (t in 1:n.steps){
        
        c[yr, j, t] <- beta.cos[yr, j] * cos(2 * pi * t / period) + beta.sin[yr, j] * sin(2 * pi * t / period)
      }  
    }
  }
    
  # priors
  for (yr in 1:n.years){
    for (j in 1:n.sectors){
      beta.cos[yr, j] ~ dnorm(0, tau.cos)
      beta.sin[yr, j] ~ dnorm(0, tau.sin)

    }
  }
  
   sigma.cos ~ dgamma(1, 0.1)
  sigma.sin ~ dgamma(1, 0.1)
  
  tau.cos <- 1/(sigma.cos * sigma.cos)
  tau.sin <- 1/(sigma.sin * sigma.sin)
  
  sigma.y ~ dgamma(1, 0.1)
  tau.y <- 1/(sigma.y * sigma.y)

  #for (j in 1:n.sectors){
    # observation SD and precision - needs to be petty tight 
    # for convergence because data are so limited
    #sigma.y[j] ~ dgamma(1, 0.1)
    #tau.y[j] <- 1/(sigma.y[j] * sigma.y[j])

    # sigma.X is the SD of the process (X)
    #sigma.X[j] ~ dgamma(1, 0.1)
    #tau.X[j] <- 1/(sigma.X[j] * sigma.X[j])    
        
  #}
}
