---
title: "R Notebook"
output: html_notebook
---

This notebook describes an attempt to use Richards' function to estimate the true N in the N-mixture model of Granite Canyon counts. The observed counts are binomial deviates with the "true" N and capture probabilities that are affected by covariates; Beaufort sea state, visibility, and observers.  


The station information needs to be added. The data files that I have don't have that info... this needs to be fixed in the future. 

Set up libraries

```{r}
rm(list=ls())
library(abind)
library(jagsUI)
library(tidyverse)
library(bayesplot)
# library(mgcv)
# library(splines)

# Poisson seems to work better than binomial
#obs.model <- "pois"
#obs.model <- "bino"
#models <- "norm_bino"
#models <- "norm_pois"
models <- "pois_bino"
#jags.model <- paste0("models/model_Richards_", models, ".txt")
jags.model <- paste0("models/model_Richards_", models, ".txt")

out.file.name <- paste0("RData/JAGS_Richards_v1_", models, 
                        "_", Sys.Date(), ".RData")

# Observer list gets updated as new observers are added. 
# obs.list <- read.csv("Data/Observer list.csv", header = T) 
# colnames(obs.list) <- c("obs", "ID")
seasons <- c("2006/2007", "2007/2008", "2009/2010", "2010/2011",
             "2014/2015", "2015/2016", "2019/2020", "2021/2022")

#seasons <- c("2014/2015", "2015/2016", "2019/2020", "2021/2022")

n.seasons <- length(seasons)

# Load the most recent data that were newly extracted for the last four surveys:
# Using Final_Data, which contains only data for observation periods that are 90 +/- 5 minutes
# This can be changed to use all data (Data_Out) in the future 2022-09-06 - this was
# done and seemed to work fine. See below. I'm now using Durban's data. I don't know
# how this dataset was extracted as it has "v2" on it... Compare it to "v1" later. 2022-09-15

# Final_Data <- list()
# k <- 3
# for (k in 1:length(seasons)){
#   tmp <- readRDS(paste0("RData/V2.1_Aug2022/out_",
#                         strsplit(seasons[k], "/")[[1]][2],
#                         "_Tomo_v2.rds"))
# 
#   #Final_Data[[k]] <- tmp$Final_Data %>%
#   Final_Data[[k]] <- tmp$Data_Out %>%  
#     mutate(Year = as.numeric(strsplit(seasons[k], "/")[[1]][2]),
#            Day = as.numeric(BeginDay)) %>%
#     # right_join(., data.frame(Day = 1:90,
#     #                          n = NA,
#     #                          Year = as.numeric(strsplit(seasons[k], "/")[[1]][2])), 
#     #            by = "Day") %>%
#     # 
#     # select(Year.y, Day, n.x, n.y, dur, bf, vs, obs, begin) %>%
#     # mutate(n = n.x,
#     #        effort = ifelse(is.na(dur), 0, dur),
#     #        Year = Year.y) %>%
#     # select(-c(Year.y, n.x, n.y, dur)) %>%
#     # arrange(Day) 
#     mutate(effort = dur) %>%
#     select(Year, Day, effort, bf, vs, n, obs)
#   
#     #complete(Day, i) %>%
#     #filter(!is.na(i))
# 
# }
# 
# Final_Data.all <- do.call(rbind, Final_Data)
# Final_Data.all$St <- 1            # for this one, we only have 1 station (2022-08-19)
# 
# # Find all observers and change them into integer code:
# unique.obs <- unique(Final_Data.all$obs)
# unique.obs <- unique.obs[!is.na(unique.obs)]
# obs.ID.df <- data.frame(obs = unique.obs,
#                         obs.ID = 1:length(unique.obs))
# 
# Final_Data.all %>% 
#   left_join(obs.ID.df, by = "obs") %>% 
#   select(-obs) -> Final_Data.all
# 
# # figure out the number of periods
# Final_Data.all %>% 
#   group_by(Year) %>%
#   #filter(effort > 0) %>%
#   summarise(n = n()) -> periods
# 
# Final_Data.all$n[Final_Data.all$effort == 0] <- NA
# 
# years <- unique(Final_Data.all$Year)

data.8yr.v2 <- readRDS("RData/WinBUGS_8yr_v2.rds")
data.WinBUGS <- data.8yr.v2$jags.data

out.file.name <- paste0("RData/JAGS_Richards_v1_", models, 
                        "_8yr_v2_", Sys.Date(), ".RData")

```

The daily mean is a function of days (1:90)

```{r data_setup}
# Final_Data.all %>% 
#   group_by(Year, Day) %>%
#   summarise(daily.effort = sum(effort, na.rm = T)) %>%
#   pivot_wider(values_from = daily.effort,
#               names_from = Year,
#               names_prefix = "Y")-> daily.effort
# 
# # daily.effort %>%
# #   #group_by(Day) %>%
# #   summarise_at(vars(Y2015:Y2022), funs(Day[. > 0][1])) %>%
# #   select(starts_with("Y")) -> first.day
# 
# Final_Data.all %>% 
#   group_by(Year, Day) %>%
#   summarise(daily.counts = sum(n, na.rm = T)) %>%
#   pivot_wider(values_from = daily.counts,
#               names_from = Year,
#               names_prefix = "Y")-> daily.counts
# 
# # Final_Data.all %>% 
# #   group_by(Year, Day) %>%
# #   summarise(daily.effort = sum(effort, na.rm = T),
# #             daily.counts = sum(n, na.rm = T)) %>%
# #   mutate(daily.N = daily.counts/daily.effort) %>%
# #   select(-c(daily.effort, daily.counts)) %>%
# #   pivot_wider(values_from = daily.N,
# #               names_from = Year,
# #               names_prefix = "Y")-> daily.N
# 
# Final_Data.all %>%
#   group_by(Year, Day) %>%
#   summarise(daily.effort = sum(effort, na.rm = T),
#             daily.counts = sum(n, na.rm = T)) %>%
#   mutate(daily.N = ceiling(daily.counts/daily.effort) ) %>%
#   select(-c(daily.effort, daily.counts)) %>%
#   pivot_wider(values_from = daily.N,
#               names_from = Year,
#               names_prefix = "Y") %>%
#   right_join(y = data.frame(Day = seq(1:90)),
#              by = "Day") %>%
#   arrange(Day) -> daily.N
# 
# daily.N[is.na(daily.N)] <- 0
# 
# Final_Data.all %>% 
#   group_by(Year, Day) %>%
#   summarise(daily.obs = first(obs.ID)) %>%
#   pivot_wider(values_from = daily.obs,
#               names_from = Year,
#               names_prefix = "Y")-> daily.obs
# 
# n.per.day <- obs.all <- n.all <- array(data = 0, 
#                                        dim = c(max(periods$n), 2, length(seasons)))
# 
# days.all <- bf.all <- vs.all <- watch.prop <- matrix(data = NA,
#                                                      nrow = max(periods$n), 
#                                                      ncol = length(seasons))
# 
# for (k in 1:length(seasons)){
#   n.all[1:periods$n[k],1, k] <- Final_Data[[k]]$n
#   n.per.day[1:periods$n[k],1, k] <- Final_Data[[k]]$n/Final_Data[[k]]$effort
#   bf.all[1:periods$n[k],k] <- Final_Data[[k]]$bf
#   vs.all[1:periods$n[k],k] <- Final_Data[[k]]$vs
#   # 540 minutes (maximum observation duration in a day) in unit of days
#   watch.prop[1:periods$n[k],k] <- Final_Data[[k]]$effort/(540/24/60)
#   
#   days.all[1:periods$n[k],k] <- Final_Data[[k]]$Day
#   
#   obs.all[1:periods$n[k],1, k] <- Final_Data.all %>% 
#     filter(Year == years[k]) %>%
#     select(obs.ID) %>% 
#     pull() 
# }
# 
# #bf.all[is.na(bf.all)] <- 0
# #vs.all[is.na(vs.all)] <- 0
# obs.all[is.na(obs.all)] <- max(obs.ID.df$obs.ID) + 1
# n.per.day[is.na(n.per.day)] <- 0

```


$$M_1 = (1 + (2 e^K - 1) * e^{(P-d)/(-S)}) ^ {(-1/e^K)}$$

$$M_2 = (1 + (2 e^K - 1) * e^{(P-d)/(S)}) ^ {(-1/e^K)}$$

$$N = min_N + (max_N - min_N) * (M_1 * M_2),$$ 

where $d$ is the number of days from the beginning of nesting season,

$S$ defines the "fatness" of the function ($S > 0$),

$K > 0$ defines the "flatness" at the peak of the function,

$P$ defines where the peak is relative to the range of $d$, where $min(d) < P < max(d)$,

$min_N$ is "the basal level of nesting outside the nesting season" and,

$max_N >> min_N$



```{r run-jags}
MCMC.params <- list(n.samples = 100000,
                    n.thin = 10,
                    n.burnin = 80000,
                    n.chains = 5)

jags.params <- c("lambda","OBS.RF","OBS.Switch",
                "BF.Switch","BF.Fixed","VS.Switch",
                "VS.Fixed","mean.prob",
                "BF.Fixed",
                "VS.Fixed", "mean.N", "max",
                "Corrected.Est","Raw.Est","N",
                "K", "S1", "S2", "P", "cv.N",
                "sigma.N", "log.lkhd")

jags.data <- list(  n = data.WinBUGS$n,
                    n.station = rep(1, times = 8),
                    n.year = length(seasons),
                    n.obs = data.WinBUGS$n.obs,
                    #Daily.N = daily.N,
                    periods = data.WinBUGS$periods,
                    #first.day = unlist(as.vector(first.day)),
                    obs = data.WinBUGS$obs,
                    vs = data.WinBUGS$vs,
                    bf = data.WinBUGS$bf,
                    watch.prop = data.WinBUGS$Watch.Length,
                    day = data.WinBUGS$day,
                    max.vec = rep(1000, times = 4))

jm <- jags(jags.data,
             inits = NULL,
             parameters.to.save= jags.params,
             model.file = jags.model,
             n.chains = MCMC.params$n.chains,
             n.burnin = MCMC.params$n.burnin,
             n.thin = MCMC.params$n.thin,
             n.iter = MCMC.params$n.samples,
             DIC = T, parallel=T)



# This is the output file name
# jags.out.file <- paste0("RData/jagam_dailyN_k", 
#                         basis.dim, "_", family, "_jags.rds")

```




```{r}
# mcmc_trace(jm$samples, c("K[1]", "K[2]",
#                          "K[3]", "K[4]"))

mcmc_trace(jm$samples, "K")

```



```{r}
#mcmc_dens(jm$samples, c("K[1]", "K[2]",
#                         "K[3]", "K[4]"))

mcmc_dens(jm$samples, "K")

```



```{r}
mcmc_trace(jm$samples, c("S1[1]", "S1[2]",
                         "S1[3]", "S1[4]",
                         "S1[5]", "S1[6]",
                         "S1[7]", "S1[8]"))

```




```{r}
mcmc_dens(jm$samples, c("S1[1]", "S1[2]",
                         "S1[3]", "S1[4]",
                         "S1[5]", "S1[6]",
                         "S1[7]", "S1[8]"))

```



```{r}
mcmc_trace(jm$samples, c("S2[1]", "S2[2]",
                         "S2[3]", "S2[4]",
                         "S2[5]", "S2[6]",
                         "S2[7]", "S2[8]"))

```




```{r}
mcmc_dens(jm$samples, c("S2[1]", "S2[2]",
                         "S2[3]", "S2[4]",
                         "S2[5]", "S2[6]",
                         "S2[7]", "S2[8]"))

```

```{r}
mcmc_trace(jm$samples, c("BF.Fixed", "VS.Fixed"))
```


```{r}
#mcmc_trace(jm$samples, "cv.N")
```


```{r}
# mcmc_trace(jm$samples, c("max[1]", "max[2]",
#                          "max[3]", "max[4]"))

mcmc_trace(jm$samples, "max")

```



```{r}
#mcmc_dens(jm$samples, c("max[1]", "max[2]",
#                         "max[3]", "max[4]"))

mcmc_dens(jm$samples, c("max"))

```


How do estimates look?


```{r}

mean.N.hats <- data.frame(Season = rep(seasons, each = 90),
                     Day = rep(1:90, times = 4),
                     Mean = as.vector(jm$mean$mean.N),
                     LCL = as.vector(jm$q2.5$mean.N),
                     UCL = as.vector(jm$q97.5$mean.N))

                     
ggplot(mean.N.hats %>% group_by(Season)) + 
  geom_ribbon(aes(x = Day, ymin = LCL, ymax = UCL),
              fill = "blue", alpha = 0.5) +
  geom_path(aes(x = Day, y = Mean)) + 
  facet_wrap(~ Season)



```



```{r}

N.hats <- data.frame(Season = rep(seasons, each = 90),
                     Day = rep(1:90, times = 4),
                     Mean = as.vector(jm$mean$N),
                     LCL = as.vector(jm$q2.5$N),
                     UCL = as.vector(jm$q97.5$N))


ggplot(N.hats %>% group_by(Season)) + 
  geom_ribbon(aes(x = Day, ymin = LCL, ymax = UCL),
              fill = "blue", alpha = 0.5) +
  geom_path(aes(x = Day, y = Mean)) + 
  facet_wrap(~ Season)



```


```{r}
n.st1 <- jags.data$n[,1,]
obsd.n <- data.frame(Season = rep(seasons, each = nrow(n.st1)),
                     Day = as.vector(jags.data$day),
                     n = as.vector(n.st1)) %>% na.omit()
                     
ggplot(obsd.n %>% group_by(Season)) +
  geom_point(aes(x = Day, y = n)) +
  facet_wrap(~Season)
```


```{r}
# Check conversions
mcmc_trace(jm$samples, c("Corrected.Est[1]", "Corrected.Est[2]",
                         "Corrected.Est[3]", "Corrected.Est[4]",
                         "Corrected.Est[5]", "Corrected.Est[6]",
                         "Corrected.Est[7]", "Corrected.Est[8]"))

```


```{r}
mcmc_dens(jm$samples, c("Corrected.Est[1]", "Corrected.Est[2]",
                         "Corrected.Est[3]", "Corrected.Est[4]",
                         "Corrected.Est[5]", "Corrected.Est[6]",
                         "Corrected.Est[7]", "Corrected.Est[8]"))

```

```{r}
save.image(file = out.file.name)

```

