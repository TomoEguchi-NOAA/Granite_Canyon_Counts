---
title: "A new approach to gray whale abundance estimation"
author: "Tomo Eguchi"
date: "`r Sys.Date()`"
output: 
  bookdown::word_document2: default
---


```{r setup, include=FALSE}
rm(list = ls())
knitr::opts_chunk$set(echo = TRUE)
save.fig <- F

source("Granite_Canyon_Counts_fcns.R")
library(tidyverse)
library(lubridate)
library(flextable)
library(jagsUI)
library(bayesplot)
library(ggpubr)
library(R2WinBUGS)

set_flextable_defaults(font.size = 9,
                       font.family = "Cambria")
```

## Introduction {-}

Analytical methods to estimate abundance of gray whales from visual surveys at Granite Canyon, CA, have evolved over the years. Laake et al. (2006?) used the distance sampling approach with generalized additive models (GAMs). Durban et al. (2016) developed a new method using a Bayesian N-mixture approach. The new approach was approved by the IWC and it has been used for the analysis since the 2015/2016 season. The analysis is conducted using WinBUGS, which has become obsolete over the last several years. In this report, I provide improvements of the method by Durban et al. where the analysis is conducted using JAGS (Plummer 2021), which is a widely used Bayesian programming language. 

The general tendency of annual migration of gray whales (or any other migratory species - find other examples) is that when the migration is observed at a location along the migration corridor, the number increases over time until it reaches its peak, then it decreases. The method by Durban et al. used a Gaussian function to capture this general trend. 

In the following, I first describe the method by Durban et al. and point out underlying assumptions that are somewhat questionable. Then, I introduce a new approach that is consistent with the basic idea of the method by Durban et al. but improve it by removing those assumptions. I show the performance of the new approach using simulated data. Finally, I reanalyze the data to compare abundance estimates between the two approaches. 


## Method by Durban et al. {-}

### Mathematical description {-}


### Difficulties of the method {-}

The approach used the "cut" function within WinBUGS to select either Gaussian or spline fit to daily count of gray whales. The use of "cut" function has been criticized (Plummer YR). Furthermore, the assumption that the number of gray whales migrating in front of the observation station follows a Gaussian function is somewhat questionable. The true curve may not be symmetrical around the peak and the peak may not be instantaneous. In other words, the peak may persist for a few days. Fitting spline functions to observed counts alleviates the problem but it loses the general idea that the number of whales increases, reaches a peak, then decreases over the migration season.  

## Improvements {-}

### Model description
In order to overcome these difficulties with the previous approach, I propose to use a more flexible function that can accommodate the general shape (increase, peak then decrease) and asymmetrical around the peak. The function is often called Richards' function and it has the following form.

$$M_1 = (1 + (2 e^K - 1) * e^{(P-d)/(S_1)}) ^ {(-1/e^K)}$$

$$M_2 = (1 + (2 e^K - 1) * e^{(P-d)/(S_2)}) ^ {(-1/e^K)}$$

$$N = N_{min} + (N_{max} - N_{min}) * (M_1 * M_2),$$ 

where $d$ is the number of days from the beginning of nesting season,

$S_1 < 0$ and $S_2 > 0$ defines how the slope decreases and increases, respectively,

$K > 0$ defines the "flatness" at the peak of the function,

$P$ defines where the peak is relative to the range of $d$, where $min(d) < P < max(d)$,

$N_{min}$ is zero, i.e., the number of whales migrating outside of a migration season and,

$N_{max} >> N_{min}$. $N_{max}$ is not the maximum number of whales migrating per day but it is a parameter that may be fixed or estimated during the analysis.  


### Function characteristics {-}

#### Effects of $S_1$ {-}

The parameter $S_1 < 0$ defines how the curve decreases from its peak. The rate of decline slows down as $S_1$ becomes smaller (Figure \@ref(fig:Figure-S1)). Because we make an assumption that there are no whales migrating at day 1 and 90, the lower bound of $S_1$ can be restricted to a certain value, e.g., -5).   

```{r S1, echo=FALSE, message=FALSE}
S1 <- c(-10, -5, -2.5, -1.2, -0.6, -0.3)
S2 <- 1.5
K <- 1
P <- 40
max.N <- 800

true.mean.N <- matrix(data = 0, nrow = 90, ncol = length(S1))

for (c in 1:length(S1)){
  for (d in 1:90){
    true.mean.N[d, c] <- floor(Richards_fcn(d = d, 
                                            S1 = S1[c], 
                                            S2 = S2,
                                            K = K, 
                                            P = P, 
                                            min = 0, max = max.N)  )
    

  }
  
}

data.df <- data.frame(Day = rep(1:90, times = length(S1)),
                      mean.N = as.vector(true.mean.N),
               
                      S1 = rep(S1, each = 90))

p.S1 <- ggplot(data = data.df) +
  geom_path(aes(x = Day, y = mean.N), color = "red") +

  facet_wrap(~ S1)

if (save.fig)
  ggsave(p.S1, filename = "figures/S1.png", dpi = 600, device = "png")

```



```{r Figure-S1, echo=FALSE, message=FALSE, fig.cap="Effects of $S_1$. In this example, $S_2 = 1.5$, $K = 1$, $P = 40$, $N_{max} = 800$."}

knitr::include_graphics("figures/S1.png")

```


#### Effects of $S_2$ {-}

The parameter $S_2 > 0$ defines how the curve increases to its peak. The rate of increase slows down as $S_2$ becomes larger (Figure \@ref(fig:Figure-S2)). Because we make an assumption that there are no whales migrating at day 1 and 90, the upper bound of $S_2$ can be restricted to a certain value, e.g., 5).

```{r S2, echo=FALSE, message=FALSE}
S1 <- -1.5
S2 <- c(0.3, 0.6, 1.2, 2.5, 5, 10)
K <- 1
P <- 40
max.N <- 800

true.mean.N <- matrix(data = 0, nrow = 90, ncol = length(S2))

for (c in 1:length(S2)){
  for (d in 1:90){
    true.mean.N[d, c] <- floor(Richards_fcn(d = d, 
                                            S1 = S1, 
                                            S2 = S2[c],
                                            K = K, 
                                            P = P, 
                                            min = 0, max = max.N)  )
    
  }
  
}

data.df <- data.frame(Day = rep(1:90, times = length(S2)),
                      mean.N = as.vector(true.mean.N),

                      S2 = rep(S2, each = 90))

p.S2 <- ggplot(data = data.df) +
  geom_path(aes(x = Day, y = mean.N), color = "red") +

  facet_wrap(~ S2)

if (save.fig)
  ggsave(p.S2, filename = "figures/S2.png", dpi = 600, device = "png")

```


```{r Figure-S2, echo=FALSE, message=FALSE, fig.cap="Effects of $S_2$. In this example, $S_1 = -1.5$, $K = 1$, $P = 40$, $N_{max} = 800$."}

knitr::include_graphics("figures/S2.png")

```


#### Effects of K {-}

The parameter $K > 0$ defines the flatness of the curve at its peak. Greater $K$ values correspond to flatter peaks (Figure \@ref(fig:Figure-K)). Similarly to $S_1$ and $S_2$, the upper bound of $K$ may be defined based on the assumption that the numbers of migrating gray whales are zero at day 1 and 90, e.g., $K < 2$. 

```{r K, echo=FALSE, message=FALSE}
S1 <- -2.5
S2 <- 2.5
K <- c(0.01, 0.1, 1, 2, 4, 8)
P <- 40
max.N <- 800

true.mean.N <- matrix(data = 0, nrow = 90, 
                           ncol = length(K))

for (c in 1:length(K)){
  for (d in 1:90){
    true.mean.N[d, c] <- floor(Richards_fcn(d = d, 
                                            S1 = S1, 
                                            S2 = S2,
                                            K = K[c], 
                                            P = P, 
                                            min = 0, max = max.N)  )
    
  }
  
}

data.df <- data.frame(Day = rep(1:90, times = length(K)),
                      mean.N = as.vector(true.mean.N),
                      K = rep(K, each = 90))

p.K <- ggplot(data = data.df) +
  geom_path(aes(x = Day, y = mean.N), color = "red") +
  facet_wrap(~ K)

if (save.fig)
  ggsave(p.K, filename = "figures/K.png", dpi = 600, device = "png")

```


```{r Figure-K, echo=FALSE, message=FALSE, fig.cap="Effects of $K$. In this example, $S_1 = -2.5$, $S_2 = 2.5$, $P = 40$, $N_{max} = 800$."}

knitr::include_graphics("figures/K.png")

```



#### Effects of P {-}

The parameter $P$ defines the location of its peak (Figure \@ref(fig:Figure-P)). 

```{r P, echo=FALSE, message=FALSE}
S1 <- -2.5
S2 <- 2.5
K <- 1.5
P <- c(20, 40, 60, 80)
max.N <- 800

true.mean.N <- matrix(data = 0, nrow = 90, 
                           ncol = length(P))

for (c in 1:length(P)){
  for (d in 1:90){
    true.mean.N[d, c] <- floor(Richards_fcn(d = d, 
                                            S1 = S1, 
                                            S2 = S2,
                                            K = K, 
                                            P = P[c], 
                                            min = 0, max = max.N)  )
    
  }
  
}

data.df <- data.frame(Day = rep(1:90, times = length(P)),
                      mean.N = as.vector(true.mean.N),
                      P = rep(P, each = 90))

p.P <- ggplot(data = data.df) +
  geom_path(aes(x = Day, y = mean.N), color = "red") +
  facet_wrap(~ P)

if (save.fig)
  ggsave(p.P, filename = "figures/P.png", dpi = 600, device = "png")

```


```{r Figure-P, echo=FALSE, message=FALSE, fig.cap="Effects of $P$. In this example, $S_1 = -2.5$, $S_2 = 2.5$, $K = 1.5$, $N_{max} = 800$."}

knitr::include_graphics("figures/P.png")

```


#### Fitting the model to observed counts {-}

The proposed new approach replaces the spline-Gaussian selection step in Durban et al. with Richards functions. The observed counts are modeled with binomial distributions as it was in Durban et al.

$$ n_{d_t,s,y} \sim BIN(N_{t, y}, p_{d_t, s, y} * \theta_{d_t, y}) $$
where $n_{d_t, s, y}$ is the observed number of gray whales during the watch period $d$ of the $t$-th day of the season $y$ from the station $s$, $N_{t, y}$ is the number of gray whales that migrated through the sampling area during the $t$-th day,  $p_{d_t, s, y}$ is the sighting probability of the station $s$ during the watch period $d$ of the $t$-th day of the season $y$, and $\theta_{d_t,y}$ is the fractional duration of the watch period $d_t$ to the total possible (9 hrs), e.g., 3 hrs equals to 3/9 = 0.3.

The sighting probability $p_{d_t, s, y}$ is modeled as a function of Beaufort sea state, visibility, and observers. Beaufort sea state and visibility were treated as fixed effects, whereas observers were treated as a random effect. Furthermore, additional parameters were added to determine whether or not to include any of these covariates. 


$$ logit(p_{d_t, s, y}) = \beta_0 + I_{BF} * \beta_{BF} * BF_{d_t, y} + I_{VS} * \beta_{VS} * VS_{d_t, y} + I_{OBS} * OBS_{d_t, s, y}  $$

This is identical to how the sighting probability was modeled in Durban et al. (2016).


The number of gray whales that migrated through the sampling area during the $t$-th day of the season was modeled as a random Poisson variable with the mean $\bar{N}_{t, y}$, 

$$ N_{t, y} \sim POI(\bar{N}_{t,y}) $$

where $\bar{N}_t$ is the "mean" number of whales that expected to migrate through the sampling area on the $t$-th day of the season $y$ and modeled with Richards functions above. 

I used Poisson distribution for this hierarchical model based on the finding in Raftery (1988). 

The total number of gray whales for season $y$ is the sum of all $N_{t, y}$ and corrected for nighttime passage:

$$ N_y = \lambda * \sum_{t = 1} ^ {90} N_{t, y} $$ and 

$$ \lambda \sim N(1.0875, 0.03625) $$ (Perryman et al. YR). 



### Performance of the new approach

#### Simulation

To evaluate the performance of the new approach using Richards functions, I simulated data using the above relationships. To test for a mismatch between the within-season mean function, with respect to the number of days since day 1, I used a gamma distribution function (GAM(3, 0.07) * 5000) instead of Richards functions (R())to define the mean values for one year and used Richards functions for the other year. 


$$ \bar{N}_{1,t} = GAM(t, 3, 0.07) $$, 

where t = 1, ..., 90.

$$ \bar{N}_{2,t} = R(t, S_1 = -0.9, S_2 = 1.5, P = 48, K = 2.5, max = 500) $$, 

where t = 1, ..., 90.

The shape of the gamma function is shwon in Figure \@ref(fig:Figure-Gam-def).

```{r gam_fcn, echo=FALSE, message=FALSE}
gam.def <- data.frame(x = seq(0, 100, by = 0.01)) %>%
  mutate(y = dgamma(x, 5.4, 0.13) * 5000)

p.gam.def <- ggplot(gam.def) +
  geom_path(aes(x = x, y = y))

if (save.fig)
  ggsave(filename = "figures/gam_def.png", plot = p.gam.def,
         device = "png", dpi = 600)
```


```{r Figure-Gam-def, echo=FALSE, message=FALSE, fig.cap="The shape of gamma distribution function used to simulate data. This function defines $\bar{N}$. Although there are non-zero values beyond x = 90, the $\bar{N}$ was set to 0 at x = 90. "}

knitr::include_graphics("figures/gam_def.png")

```


```{r simulation, echo=FALSE, message=FALSE}
set.seed(12345)
#save.fig <- T
# Define Richards function parameters
S1 <- 0.9  # this gets fixed to a negative value in Richards_fcn. 
S2 <- 1.5
P <- 48
K <- 2.5
Max <- 200
Days <- 1:90

# Alternatively, use a different function to create real values for the means
N.mean <- matrix(nrow = 90, ncol = 2)
N.mean[,1] <- dgamma(1:90, 5.4, 0.13) * 6000
N.mean[,2] <- Richards_fcn(d = Days, S1 = S1, S2 = S2, 
                           K = K, P = P, min = 0, max = Max)

# This is by assumption
#N.mean[c(1,90), 1:2] <- 0

# Define sighting probability parameters
B0 <- 0.3
B_BF <- -1.2
B_VS <- -2.3

param.names <- c("S1[1]", "S1[2]", "S2[1]", "S2[2]", 
                 "K", "P[1]", "P[2]", 
                 "max[1]", "max[2]", 
                 "mean.prob", "BF.Fixed", "VS.Fixed")

params.df <- data.frame(names = param.names,
                        value = c(NA, S1, NA, S2, K, NA, P, NA, Max,
                                  B0, B_BF, B_VS))

Season = c("2020", "2022")
True.N <- matrix(nrow = 90, ncol = length(Season))
for (k in 1:nrow(N.mean)) {
  for (c in 1:ncol(N.mean)){
    True.N[k,c] <- rpois(n = 1, lambda = N.mean[k, c])
  }
  
}

# Use real data for observers, Beaufort, and visibility
#out.file.name <- "RData/Pois_Binom_sim_results.rds"
out.file.name <- "RData/Pois_Binom_sim_results.rds"
    
if (!file.exists(out.file.name)){
  set.seed(12345)
  Data_True.N <- list()
  periods <- vector(mode = "numeric", length = length(Season))
  for (y in 1:length(Season)){
    # I use the real data to emulate sampling and sighting conditions
    tmp <- readRDS(paste0("RData/V2.1_Aug2022/out_", Season[y], "_Tomo_v2.rds"))
    Final_Data <- tmp$Data_Out %>%
      mutate(Year = Season[y],
             Day = as.numeric(BeginDay)) %>%
      mutate(effort = dur) %>%
      mutate(watch.prop = effort * 24/9) %>%
      select(Year, Day, effort, watch.prop, bf, vs, n, obs)
    
    # Find all observers and change them into integer code:
    unique.obs <- unique(Final_Data$obs)
    unique.obs <- unique.obs[!is.na(unique.obs)]
    obs.ID.df <- data.frame(obs = unique.obs,
                            obs.ID = 1:length(unique.obs))
    
    Final_Data %>% 
      left_join(obs.ID.df, by = "obs") %>% 
      select(-obs) -> Final_Data
    
    # figure out the number of periods
    Final_Data %>% 
      group_by(Year) %>%
      #filter(effort > 0) %>%
      summarise(n = n()) -> n.days
    
    periods[y] <- n.days$n
    
    Final_Data$n[Final_Data$effort == 0] <- NA
    
    # Create sighting probabilities
    Final_Data %>%
      mutate(Sighting.Prob.lm = as.vector(B0 + B_BF * scale(bf) + 
                                            B_VS * scale(vs)),
             Sighting.Prob = exp(Sighting.Prob.lm)/(1 + exp(Sighting.Prob.lm)),
             Binom.Prob = watch.prop * Sighting.Prob) -> Final_Data
    
    Final_Data %>%
      left_join(data.frame(Day = Days,
                           N.mean = N.mean[,y],
                           N.True = True.N[,y]), 
                by = "Day") -> Data_True.N[[y]]
  }
  

  max.n.rows <- lapply(Data_True.N, FUN = nrow) %>% 
    unlist() %>% 
    max()
  
  watch.prop <- bf <- vs <- day <- effort <- array(dim = c(max.n.rows, length(Season)))
  obs <- obsd.n <- array(dim = c(max.n.rows, 1, length(Season)))
  
  for (y in 1:length(Season)){
    
    for (k in 1:nrow(Data_True.N[[y]])){
      obsd.n[k, 1, y] <- rbinom(n = 1, 
                                size = Data_True.N[[y]]$N.True[k], 
                                prob = Data_True.N[[y]]$Binom.Prob[k])
      
      obs[k,1,y] <- Data_True.N[[y]]$obs.ID[k]
      watch.prop[k, y] <- Data_True.N[[y]]$watch.prop[k]
      effort[k,y] <- Data_True.N[[y]]$effort[k]
      
      bf[k, y] <- Data_True.N[[y]]$bf[k]
      vs[k, y] <- Data_True.N[[y]]$vs[k]
      day[k, y] <- Data_True.N[[y]]$Day[k]
    }
  }
  
  #Data_True.N$obsd.n <- obsd.n
  
  MCMC.params <- list(n.samples = 120000,
                      n.thin = 10,
                      n.burnin = 100000,
                      n.chains = 5)
  
  jags.model <- paste0("models/model_Richards_pois_bino.txt")
  
  jags.params <- c("OBS.RF", "OBS.Switch",
                   "BF.Switch", "BF.Fixed", 
                   "VS.Switch", "VS.Fixed",
                   "mean.prob", "mean.N", "max",
                   "Corrected.Est", "Raw.Est", "N",
                   "K", "S1", "S2", "P",
                   "log.lkhd")
  
  jags.data <- list(  n = obsd.n, 
                      n.station = c(1,1),
                      n.year = length(Season),
                      n.obs = length(unique(na.omit(as.vector(obs)))) + 1,
                      periods = periods,
                      obs = obs,
                      vs = scale(vs),
                      bf = scale(bf),
                      watch.prop = watch.prop,
                      day = day,
                      effort = effort,
                      bf.raw = bf,
                      vs.raw = vs)
  #max.vec = c(3000, 3000))
  
  Start_Time<-Sys.time()
  
  jm <- jags(jags.data,
             inits = NULL,
             parameters.to.save= jags.params,
             model.file = jags.model,
             n.chains = MCMC.params$n.chains,
             n.burnin = MCMC.params$n.burnin,
             n.thin = MCMC.params$n.thin,
             n.iter = MCMC.params$n.samples,
             DIC = T, parallel=T)
  
  Run_Time <- Sys.time() - Start_Time
  jm.out <- list(jm = jm,
                 jags.data = jags.data,
                 jags.params = jags.params,
                 jags.model = jags.model,
                 MCMC.params = MCMC.params,
                 Run_Time = Run_Time)
  
  saveRDS(jm.out,
          file = out.file.name)
  
} else {
  
  jm.out <- readRDS(out.file.name)
}



```



#### Estimated parameters of simulated data

```{r jags-posteriors, echo=FALSE, message=FALSE, warning=FALSE}
max.r.hat <- max(unlist(lapply(jm.out$jm$Rhat, 
                               FUN = max, 
                               na.rm = T)))
#jm <- jm.out$jm
#true.values <- c(S1, S2, K, P, B0, B_BF, B_VS)
# params <- data.frame(name = param.names,
#                      value = true.values)

plots.trace <- function(jm, params){
  out.list <- list()
  for (i in 1:length(params)){
    if (i < 7){
      p.tmp <- mcmc_trace(jm$samples, params[i]) +
        legend_none() + xaxis_text(on = FALSE) +
        hline_at(params.df[i, "value"], color = "red", size = 1.2)
      
    } else {
      p.tmp <- mcmc_trace(jm$samples, params[i]) +
        legend_none() +
        hline_at(params.df[i, "value"], color = "red", size = 1.2)

    }

    out.list[[i]] <- p.tmp 
  }
  return(out.list)
}

plots.dens <- function(jm, params){
  out.list <- list()
  for (k in 1:length(params)){
    out.list[[k]] <- mcmc_dens(jm$samples, params[k]) #+

  }
  
  return(out.list)
}

p.trace <- plots.trace(jm.out$jm, params = param.names)
p.dens <- plots.dens(jm.out$jm, params = param.names)

if (save.fig){
  for (k in 1:length(param.names)){
    ggsave(plot = p.trace[[k]] + 
             geom_hline(aes(yintercept = params.df[k, "value"]),
                        color = "red", size = 1.2),
           filename = paste0("figures/", param.names[k], "_sim_trace.png"),
           
           dpi = 600, 
           device = "png",
           height = 3, width = 3, units = "in")
    
    ggsave(filename = paste0("figures/", param.names[k], "_sim_dens.png"),
           plot = p.dens[[k]],
           dpi = 600, device = "png",
           height = 3, width = 3, units = "in")
    
  }
  
}

obsd.n.df <- data.frame(Season = c(rep(Season[1], jm.out$jags.data$periods[1]), 
                                   rep(Season[2], jm.out$jags.data$periods[2])),
                        day = c(jm.out$jags.data$day[1:jm.out$jags.data$periods[1],1],
                                jm.out$jags.data$day[1:jm.out$jags.data$periods[2],2]),
                        n = c(jm.out$jags.data$n[1:jm.out$jags.data$periods[1],1,1],
                              jm.out$jags.data$n[1:jm.out$jags.data$periods[2],1,2]))

mean.N.hats <- data.frame(Season = rep(Season, each = 90),
                          Day = rep(1:90, length(Season)),
                          Mean = as.vector(jm.out$jm$mean$mean.N),
                          LCL = as.vector(jm.out$jm$q2.5$mean.N),
                          UCL = as.vector(jm.out$jm$q97.5$mean.N),
                          true.mean = as.vector(N.mean))

p.mean.N.hats <- ggplot(mean.N.hats %>% group_by(Season)) + 
  geom_ribbon(aes(x = Day, ymin = LCL, ymax = UCL),
              fill = "blue", alpha = 0.5) +
  geom_path(aes(x = Day, y = Mean)) + 
  geom_path(aes(x = Day, y = true.mean), color = "gold") +
  facet_wrap(~ Season)

if (save.fig)
  ggsave(p.mean.N.hats, filename = "figures/mean_N_sim.png",
         device = "png", dpi = 600)

N.hats <- data.frame(Season = rep(Season, each = 90),
                     Day = rep(1:90, times = length(Season)),
                     Mean = as.vector(jm.out$jm$mean$N),
                     LCL = as.vector(jm.out$jm$q2.5$N),
                     UCL = as.vector(jm.out$jm$q97.5$N),
                     true.N = as.vector(True.N))

p.N.hats <- ggplot(N.hats) + 
  geom_ribbon(aes(x = Day, ymin = LCL, ymax = UCL),
              fill = "blue", alpha = 0.5) +
  geom_path(aes(x = Day, y = Mean)) + 
  geom_path(aes(x = Day, y = true.N), color = "gold") +
  geom_point(data = obsd.n.df, aes(x = day, y = n))+
  facet_wrap(~ Season)

if (save.fig)
  ggsave(p.N.hats, filename = "figures/N_hats_sim.png",
         device = "png", dpi = 600)

p.trace.all <- cowplot::plot_grid(plotlist = p.trace, 
                                  ncol = 2)

if (save.fig)
  cowplot::save_plot(p.trace.all, 
                     filename = "figures/trace_plots_sim.png",
                     device = "png", dpi = 600, bg = "white")

```


Convergence was reached for all parameters according to the @\hat{R}$ statistic, where the maximum value was `r signif(max.r.hat, 3)`. However, trace plots of some Richards function parameters did not look ideal (Figure \@ref(fig:Figure-trace)). The observed poor conversions of S1, S2, and max parameters might have been caused by the mismatch between the true function (gamma) and assumed (Richards) function, where Richards functions could not match the increase (S2) and decrease (S1) of the gamma function.

For the parameters that associated with sighting probabilities (mean.prob, BF.Fixed, and VS.Fixed), MCMC samples appeared to converge, albeit not around the true values (Figure \@ref(fig:Figure-trace)). 

```{r Figure-trace, echo=FALSE, message=FALSE, fig.cap="Trace plots of parameters. Red horizontal lines indicate the true values. Not all plots contain true values because the data generating function for one year (gamma distribution) was different from the estimation function (Richards function)."}

knitr::include_graphics("figures/trace_plots_sim.png")

```


Even with the apparent poor conversion of a few parameters, estimated $\bar{N}$ and $N$ were qualitatively acceptable (Figures \@ref(fig:Figure-mean-N) and \@ref(fig:Figure-N)).

```{r Figure-mean-N, echo=FALSE, message=FALSE, fig.cap = "Estimated $\bar{N}$ and their 95% CI (blue ribbon) and the true $\bar{N}$ in gold."}

knitr::include_graphics("figures/mean_N_sim.png")
```


```{r Figure-N, echo=FALSE, message=FALSE, fig.cap = "Estimated $N$ and their 95% CI (blue ribbon) and the true $N$ in gold."}

knitr::include_graphics("figures/N_hats_sim.png")
```


#### Comparison to Durban et al's method

In order to compare the new method to the current method (Durban et al.), I analyzed the same dataset with the analytical approach in Durban et al. 


```{r WinBugs-Analysis, echo=FALSE, message=FALSE}
WinBUGS.dir <- paste0(Sys.getenv("HOME"), "/WinBUGS14")
BUGS.model <- "GW_Nmix_Orig.bugs"

# The following is from WinBUGS Ver2.Rmd. It ran fine. I saved data and inits from
# the run and saved it in an rds file. Compare data and inits. Data look okay.
# Look at inits 2022-10-04
data.worked <- readRDS("RData/BUGS_data_runs.rds")


x <- length(Season)

jags.data <- jm.out$jags.data
MCMC.params <- jm.out$MCMC.params

u <- jags.data$n
u[!is.na(u)] <- 1
u[is.na(u)] <- 0

day <- rbind(jags.data$day, matrix(NA, nrow = 2, ncol = x))
#BUGS.n <- abind::abind(jags.data$n, array(data = NA, dim = c(2, 1, x)), along = 1)

for(i in 1:x){ #Set the anchor points: days 1 and 90
  day[(jags.data$periods[i]+1):(jags.data$periods[i]+2),i] <- c(1,90)
  #BUGS.n[(jags.data$periods[i]+1):(jags.data$periods[i]+2), 1, i] <- c(0,0)
}

#The 'data' has to be the inverse of the inits, 
# with NAs for all of the estimated Ns, and 0s for the days 1 and 90
N <- matrix(NA, 
            nrow=max(jags.data$periods)+2, 
            ncol=x) 

#True number of whales passing fixed at 0 for day 1 and 90
for(i in 1:x){
  N[(jags.data$periods[i]+1):(jags.data$periods[i]+2),i] <- 0 
}

#we're going to make N a partially observed data object with anchor points at day 1 and 90
# TE: I don't know how these numbers were created... they are generally 2x n (not all)
# N_inits <- as.matrix(read.table("Data/Initial Values/N_inits.txt",
#                                 header=T))

N_inits1 <- jags.data$n[, 1,] * 2 + 2
#N_inits2 <- jags.data$n[, 2,] * 2 + 2 
            
N_inits <- N_inits1
#N_inits[N_inits1 < N_inits2] <- N_inits2[N_inits1 < N_inits2]

N_inits <- rbind(N_inits,
                 matrix(data = NA, 
                        nrow = 2, 
                        ncol = x))

for (k in 1:length(jags.data$periods)){
  N_inits[(jags.data$periods[k]+1):nrow(N_inits), k] <- NA  
}

N_inits <- N_inits[,1:x]

Watch.Length <- rbind(jags.data$effort,
                      matrix(data = NA, 
                             nrow = 2,
                             ncol = x))

Watch.Length[is.na(Watch.Length)] <- 0

BUGS.data <- list(n = jags.data$n,
                  n.com = jags.data$n,
                  n.sp = jags.data$n,
                  n.station = dim(jags.data$n)[2],
                  n.year = dim(jags.data$n)[3],
                  n.obs = jags.data$n.obs,
                  periods = jags.data$periods,
                  obs = jags.data$obs,
                  #Watch.Length = 0.0625,
                  u = u,
                  vs = jags.data$vs.raw,
                  bf = jags.data$bf.raw,
                  #day=day,
                  day = day,
                  N = N,
                  N.com = N,
                  N.sp = N,
                  knot = c(-1.46,-1.26,-1.02,-0.78,
                         -0.58,-0.34,-0.10,0.10,
                         0.34,0.57,0.78,1.02,1.26,1.46),
                  n.knots = 14,
                  #begin=begin,
                  #end=end,
                  Watch.Length = Watch.Length)  

BUGS.inits <- function() list(mean.prob = 0.5,
                              BF.Fixed = 0,
                              VS.Fixed = 0,
                              mean.prob.sp = 0.5,
                              BF.Fixed.sp = 0,
                              VS.Fixed.sp = 0,
                              mean.prob.com = 0.5,
                              BF.Fixed.com = 0,
                              VS.Fixed.com = 0,
                              mean.beta = c(0,0,0), #mean.beta = c(5,0.14,-3.5),
                              beta.sigma = c(1,1,1),#beta.sigma = c(7,7,7),
                              BF.Switch = 1,
                              VS.Switch = 1,
                              OBS.Switch = 1,
                              sigma.Obs = 1,
                              BF.Switch.sp = 1,
                              VS.Switch.sp = 1,
                              OBS.Switch.sp = 1,
                              sigma.Obs.sp = 1,
                              BF.Switch.com = 1,
                              VS.Switch.com = 1,
                              OBS.Switch.com = 1,
                              sigma.Obs.com = 1,
                              N = N_inits,
                              N.com = N_inits,
                              N.sp = N_inits,
                              #z = matrix(1,nrow=90,ncol=6),
                              beta.sp = array(data=0, dim=c(2,x)),
                              sd.b.sp = rep(1, times = x), #c(1,1,1,1,1,1),
                              z = matrix(1, nrow=90, ncol= x))

# WinBUGS gives errors when N inits are set to 0. 
# Try setting them to 1 instead (seems to work):
N_inits[which(N_inits == 0, arr.ind = T)] <- 1

parameters <- c("lambda","OBS.RF","OBS.Switch",
                "BF.Switch","BF.Fixed","VS.Switch",
                "VS.Fixed","mean.prob","mean.prob.com",
                "mean.prob.sp","BF.Fixed.com",
                "BF.Fixed.sp","VS.Fixed.com",
                "VS.Fixed.sp",
                "Corrected.Est","Raw.Est","z",
                "com","sp","Daily.Est","mean.beta",
                "beta.sigma","beta","beta.sp","b.sp","sd.b.sp")

if (!file.exists(paste0("RData/WinBUGS_sim.rds"))){
  
  Start_Time<-Sys.time()
  
  bm <- bugs(data = BUGS.data,
             inits = BUGS.inits,
             parameters = parameters,
             model.file = BUGS.model, 
             n.chains = 2, #MCMC.params$n.chains,
             n.iter = 1000, #MCMC.params$n.samples, 
             n.burnin = 750, #MCMC.params$n.burnin, 
             n.thin = 5, #MCMC.params$n.thin,
             debug=T,
             bugs.directory = WinBUGS.dir)
  
  Run_Time <- Sys.time() - Start_Time
  
  BUGS.out <- list(BUGS.data = BUGS.data,
                   bm = bm,
                   N_inits = N_inits,
                   MCMC.params = MCMC.params,
                   BUGS.model = BUGS.model,
                   Run_Time = Run_Time)
  
  saveRDS(BUGS.out, 
          paste0("RData/WinBUGS_sim.rds"))
} else {
  BUGS.out <- readRDS("RData/WinBUGS_sim.rds")
  
}

#array index is greater than array upper bound for Watch.Length



```





